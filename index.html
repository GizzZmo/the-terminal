<!DOCTYPE html>
<!--
    THE TERMINAL - Cyberpunk Chess vs GM 3000 AI
    ==============================================
    
    A Matrix-themed chess game featuring:
    - Animated "Matrix rain" background effect
    - Cyberpunk neon green aesthetic
    - Interactive chess board with move validation
    - AI opponent using material evaluation (~1500-1800 ELO)
    - Real-time game log and position evaluation
    
    Technologies:
    - HTML5 Canvas for Matrix rain animation
    - chess.js library for game logic and move validation
    - Pure CSS3 for styling (no external CSS files)
    - Vanilla JavaScript (no frameworks)
    
    Author: GM 3000 AI
    License: Open Source
-->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>GM 3000 // THE TERMINAL</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.3/chess.min.js"></script>
    <style>
        /* ===================================================================
           CSS CUSTOM PROPERTIES (Variables)
           =================================================================== */
        /* Cyberpunk color scheme - neon green on black for Matrix aesthetic */
        :root {
            --neon-green: #0f0;       /* Primary accent color - Matrix green */
            --dark-green: #053305;     /* Dark green for highlights/backgrounds */
            --grid-color: #001a00;     /* Very dark green for subtle elements */
            --highlight: rgba(0, 255, 0, 0.4); /* Semi-transparent green for highlights */
            --text-glow: 0 0 5px var(--neon-green); /* Neon glow effect for text */
        }

        /* ===================================================================
           GLOBAL LAYOUT & BODY
           =================================================================== */
        /* Full-screen dark background with centered flexbox layout */
        body {
            margin: 0;
            background: black;
            color: var(--neon-green);
            font-family: 'Courier New', Courier, monospace; /* Monospace for terminal aesthetic */
            overflow: hidden; /* Prevent scrolling */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            user-select: none; /* Prevent text selection for cleaner UI */
        }

        /* ===================================================================
           MATRIX RAIN BACKGROUND
           =================================================================== */
        /* Canvas positioned behind all other elements for animated background */
        canvas#matrix {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 0;
            opacity: 0.3; /* Subtle background effect */
        }

        /* ===================================================================
           GAME CONTAINER & LAYOUT
           =================================================================== */
        /* Main container holding the chess board and HUD side-by-side */
        #game-container {
            z-index: 10; /* Above the matrix background */
            display: flex;
            flex-direction: row;
            gap: 20px;
            background: rgba(0, 10, 0, 0.85); /* Semi-transparent dark green background */
            padding: 20px;
            border: 1px solid var(--neon-green);
            box-shadow: 0 0 20px var(--dark-green); /* Glowing border effect */
            backdrop-filter: blur(5px); /* Blur effect for glassmorphism */
        }

        /* ===================================================================
           CHESS BOARD GRID
           =================================================================== */
        /* 8x8 CSS Grid for the chess board */
        #board {
            display: grid;
            grid-template-columns: repeat(8, 60px);
            grid-template-rows: repeat(8, 60px);
            border: 2px solid var(--neon-green);
        }

        /* ===================================================================
           BOARD SQUARES
           =================================================================== */
        /* Individual chess squares with pieces centered */
        .square {
            width: 60px;
            height: 60px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 40px;
            cursor: pointer;
            position: relative;
        }

        /* Standard chess board coloring - light and dark squares */
        .square.light { background: #111; }
        .square.dark { background: #000; }
        
        /* Hover effect - neon green glow on mouse over */
        .square:hover {
            box-shadow: inset 0 0 10px var(--neon-green);
        }

        /* Highlight for currently selected square */
        .square.selected {
            background: var(--dark-green) !important;
            box-shadow: inset 0 0 15px var(--neon-green);
        }

        /* Highlight for the last move made */
        .square.last-move {
            background: rgba(255, 255, 0, 0.15) !important;
            border: 1px dashed yellow;
        }

        /* ===================================================================
           CHESS PIECES
           =================================================================== */
        /* Styling for the Unicode chess piece characters */
        .piece {
            z-index: 2;
            text-shadow: 0 0 2px var(--neon-green);
            font-weight: bold;
        }

        /* ===================================================================
           HUD / SIDEBAR
           =================================================================== */
        /* Right-side panel containing game info, status, and controls */
        #hud {
            width: 300px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        /* ===================================================================
           HUD TEXT ELEMENTS
           =================================================================== */
        /* Game title and version display */
        h1 {
            margin: 0 0 10px 0;
            text-shadow: var(--text-glow);
            font-size: 24px;
            border-bottom: 1px solid var(--neon-green);
            padding-bottom: 10px;
        }

        /* Status messages (turn indicator, game state, etc.) */
        #status {
            font-size: 14px;
            margin-bottom: 20px;
            min-height: 40px;
            color: #fff;
        }

        /* ===================================================================
           GAME LOG
           =================================================================== */
        /* Scrollable game event log */
        #log {
            flex-grow: 1;
            border: 1px solid var(--dark-green);
            background: black;
            padding: 10px;
            font-size: 12px;
            overflow-y: auto;
            height: 200px;
            margin-bottom: 20px;
        }

        /* Individual log entries with timestamps */
        .log-entry { margin-bottom: 5px; }
        .log-entry span { color: #888; }

        /* ===================================================================
           BUTTONS
           =================================================================== */
        /* Control buttons with cyberpunk styling */
        button {
            background: black;
            color: var(--neon-green);
            border: 1px solid var(--neon-green);
            padding: 10px;
            font-family: inherit;
            cursor: pointer;
            transition: all 0.2s;
            text-transform: uppercase;
            font-weight: bold;
        }

        /* Button hover effect - inverted colors with glow */
        button:hover {
            background: var(--neon-green);
            color: black;
            box-shadow: 0 0 15px var(--neon-green);
        }

        /* ===================================================================
           EVALUATION BAR
           =================================================================== */
        /* Visual representation of position evaluation */
        #eval-bar {
            width: 100%;
            height: 10px;
            background: #333; /* Dark background for empty portion */
            margin-top: 10px;
            position: relative;
        }
        
        /* Animated fill showing material advantage */
        #eval-fill {
            width: 50%; /* Start at 50% (equal position) */
            height: 100%;
            background: var(--neon-green);
            transition: width 0.5s ease; /* Smooth animation when evaluation changes */
        }

        /* ===================================================================
           CONTROL PANEL & CLOCKS
           =================================================================== */
        #controls {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            margin: 10px 0;
        }

        #controls select, #controls button {
            width: 100%;
        }

        #clocks {
            display: flex;
            justify-content: space-between;
            font-size: 13px;
            margin: 10px 0;
        }

        .clock-label {
            display: flex;
            gap: 6px;
            align-items: center;
        }

        /* ===================================================================
           MOVE HISTORY
           =================================================================== */
        #move-history {
            border: 1px solid var(--dark-green);
            background: black;
            padding: 10px;
            font-size: 12px;
            overflow-y: auto;
            height: 120px;
            margin-bottom: 10px;
        }

        .move-row {
            display: flex;
            gap: 6px;
            margin-bottom: 4px;
        }

        .move-row span:first-child {
            color: #888;
            width: 32px;
        }

        .muted {
            color: #888;
        }

        /* ===================================================================
           HINT HIGHLIGHT
           =================================================================== */
        .square.hint {
            box-shadow: inset 0 0 12px rgba(0,255,255,0.6);
            border: 1px solid rgba(0,255,255,0.4);
        }

        /* ===================================================================
           RESPONSIVE DESIGN
           =================================================================== */
        /* Mobile adjustments for smaller screens */
        @media (max-width: 800px) {
            /* Stack board and HUD vertically on mobile */
            #game-container { flex-direction: column; }
            
            /* Scale board squares to viewport width */
            #board {
                grid-template-columns: repeat(8, 11vw);
                grid-template-rows: repeat(8, 11vw);
            }
            .square { width: 11vw; height: 11vw; font-size: 8vw; }
            
            /* Full width HUD on mobile */
            #hud { width: 100%; }
        }
    </style>
</head>
<body>

    <!-- Matrix Rain Background Canvas -->
    <!-- Animated background effect inspired by The Matrix -->
    <canvas id="matrix"></canvas>

    <!-- Main Game Container -->
    <!-- Contains the chess board and HUD side by side -->
    <div id="game-container">
        
        <!-- Chess Board Grid (8x8) -->
        <!-- Dynamically populated with squares and pieces by JavaScript -->
        <div id="board"></div>
        
        <!-- HUD / Sidebar Panel -->
        <!-- Contains game status, log, controls, and evaluation bar -->
        <div id="hud">
             <div>
                 <!-- Game Title and Version -->
                 <h1>GM 3000 <span style="font-size:12px; vertical-align:middle">v16.0</span></h1>
                 
                 <!-- Current Status Display -->
                 <!-- Shows turn info, game state, and system messages -->
                 <div id="status">System Ready. Awaiting Input...</div>
                 
                 <!-- Position Evaluation Bar -->
                 <!-- Visual indicator of material advantage -->
                 <div id="eval-bar"><div id="eval-fill"></div></div>
                 <div style="font-size: 10px; text-align: right; margin-top: 2px;">EVALUATION</div>

                 <!-- Control Panel -->
                 <div id="controls">
                    <select id="difficulty" onchange="setDifficulty(this.value)">
                        <option value="easy">EASY</option>
                        <option value="medium" selected>MEDIUM</option>
                        <option value="hard">HARD</option>
                    </select>
                    <button id="mode-btn" onclick="toggleMode()">Mode: VS AI</button>
                    <button id="sound-btn" onclick="toggleSound()">Sound: ON</button>
                 </div>

                 <!-- Clocks -->
                 <div id="clocks">
                    <div class="clock-label">White ⏱ <span id="white-clock">05:00</span></div>
                    <div class="clock-label">Black ⏱ <span id="black-clock">05:00</span></div>
                 </div>
             </div>
             
             <!-- Move History -->
             <div id="move-history"></div>

             <!-- Game Event Log -->
             <!-- Scrollable list of moves and game events -->
             <div id="log"></div>
             
             <!-- Control Buttons -->
             <div style="display:flex; gap:10px; flex-wrap: wrap;">
                 <button onclick="resetGame()">Reset System</button>
                 <button onclick="flipBoard()">Flip Cam</button>
                 <button onclick="undoMove()">Undo</button>
                 <button onclick="suggestMove()">Hint</button>
                 <button onclick="exportPGN()">Export PGN</button>
             </div>
         </div>
     </div>

<script>
    // ========================================================================
    // MATRIX RAIN BACKGROUND EFFECT
    // ========================================================================
    const canvas = document.getElementById('matrix');
    const ctx = canvas.getContext('2d');
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    const katakana = 'アァカサタナハマヤャラワガザダバパイィキシチニヒミリヂビピウゥクスツヌフムユュルグズブヅプエェケセテネヘメレゲゼデベペオォコソトノホモヨョロヲゴゾドボポヴッン0123456789Z';
    const latin = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
    const nums = '0123456789';
    const alphabet = katakana + latin + nums;
    const fontSize = 16;
    const columns = canvas.width / fontSize;
    const rainDrops = [];
    for (let x = 0; x < columns; x++) rainDrops[x] = 1;
    function drawMatrix() {
        ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#0F0';
        ctx.font = fontSize + 'px monospace';
        for (let i = 0; i < rainDrops.length; i++) {
            const text = alphabet.charAt(Math.floor(Math.random() * alphabet.length));
            ctx.fillText(text, i * fontSize, rainDrops[i] * fontSize);
            if (rainDrops[i] * fontSize > canvas.height && Math.random() > 0.975) rainDrops[i] = 0;
            rainDrops[i]++;
        }
    }
    setInterval(drawMatrix, 30);

    // ========================================================================
    // CHESS GAME STATE & CONFIGURATION
    // ========================================================================
    let game = new Chess();
    let boardEl = document.getElementById('board');
    let selectedSquare = null;
    let isFlipped = false;
    let twoPlayerMode = false;
    let soundEnabled = true;
    let hintSquares = [];
    let timeExpired = false;
    const INITIAL_TIME = 5 * 60;
    let timeRemaining = { w: INITIAL_TIME, b: INITIAL_TIME };
    let timerInterval = null;
    let tickingSide = 'w';

    const difficultySettings = {
        easy: { depth: 1, randomness: 0.35 },
        medium: { depth: 2, randomness: 0.15 },
        hard: { depth: 3, randomness: 0 }
    };
    let difficulty = 'medium';

    const pieces = {
        'p': '♟', 'r': '♜', 'n': '♞', 'b': '♝', 'q': '♛', 'k': '♚',
        'P': '♙', 'R': '♖', 'N': '♘', 'B': '♗', 'Q': '♕', 'K': '♔'
    };

    const pieceValues = { p: 100, n: 320, b: 330, r: 500, q: 900, k: 20000 };

    const pst = {
        p: [
            0, 0, 0, 0, 0, 0, 0, 0,
            50, 50, 50, 50, 50, 50, 50, 50,
            10, 10, 20, 30, 30, 20, 10, 10,
            5, 5, 10, 25, 25, 10, 5, 5,
            0, 0, 0, 20, 20, 0, 0, 0,
            5, -5, -10, 0, 0, -10, -5, 5,
            5, 10, 10, -20, -20, 10, 10, 5,
            0, 0, 0, 0, 0, 0, 0, 0
        ],
        n: [
            -50, -40, -30, -30, -30, -30, -40, -50,
            -40, -20, 0, 0, 0, 0, -20, -40,
            -30, 0, 10, 15, 15, 10, 0, -30,
            -30, 5, 15, 20, 20, 15, 5, -30,
            -30, 0, 15, 20, 20, 15, 0, -30,
            -30, 5, 10, 15, 15, 10, 5, -30,
            -40, -20, 0, 5, 5, 0, -20, -40,
            -50, -40, -30, -30, -30, -30, -40, -50
        ],
        b: [
            -20, -10, -10, -10, -10, -10, -10, -20,
            -10, 0, 0, 0, 0, 0, 0, -10,
            -10, 0, 5, 10, 10, 5, 0, -10,
            -10, 5, 5, 10, 10, 5, 5, -10,
            -10, 0, 10, 10, 10, 10, 0, -10,
            -10, 10, 10, 10, 10, 10, 10, -10,
            -10, 5, 0, 0, 0, 0, 5, -10,
            -20, -10, -10, -10, -10, -10, -10, -20
        ],
        r: [
            0, 0, 0, 5, 5, 0, 0, 0,
            -5, 0, 0, 0, 0, 0, 0, -5,
            -5, 0, 0, 0, 0, 0, 0, -5,
            -5, 0, 0, 0, 0, 0, 0, -5,
            -5, 0, 0, 0, 0, 0, 0, -5,
            -5, 0, 0, 0, 0, 0, 0, -5,
            5, 10, 10, 10, 10, 10, 10, 5,
            0, 0, 0, 0, 0, 0, 0, 0
        ],
        q: [
            -20, -10, -10, -5, -5, -10, -10, -20,
            -10, 0, 0, 0, 0, 0, 0, -10,
            -10, 0, 5, 5, 5, 5, 0, -10,
            -5, 0, 5, 5, 5, 5, 0, -5,
            0, 0, 5, 5, 5, 5, 0, -5,
            -10, 5, 5, 5, 5, 5, 0, -10,
            -10, 0, 5, 0, 0, 0, 0, -10,
            -20, -10, -10, -5, -5, -10, -10, -20
        ],
        k: [
            -30, -40, -40, -50, -50, -40, -40, -30,
            -30, -40, -40, -50, -50, -40, -40, -30,
            -30, -40, -40, -50, -50, -40, -40, -30,
            -30, -40, -40, -50, -50, -40, -40, -30,
            -20, -30, -30, -40, -40, -30, -30, -20,
            -10, -20, -20, -20, -20, -20, -20, -10,
            20, 20, 0, 0, 0, 0, 20, 20,
            20, 30, 10, 0, 0, 10, 30, 20
        ],
        k_end: [
            -50, -40, -30, -20, -20, -30, -40, -50,
            -30, -20, -10, 0, 0, -10, -20, -30,
            -30, -10, 20, 30, 30, 20, -10, -30,
            -30, -10, 30, 40, 40, 30, -10, -30,
            -30, -10, 30, 40, 40, 30, -10, -30,
            -30, -10, 20, 30, 30, 20, -10, -30,
            -30, -30, 0, 0, 0, 0, -30, -30,
            -50, -30, -30, -30, -30, -30, -30, -50
        ]
    };

    const openingBook = [
        { name: "Ruy Lopez", moves: ["e4", "e5", "Nf3", "Nc6", "Bb5", "a6", "Ba4", "Nf6"] },
        { name: "Italian Game", moves: ["e4", "e5", "Nf3", "Nc6", "Bc4", "Bc5", "c3", "Nf6"] },
        { name: "Queen's Gambit", moves: ["d4", "d5", "c4", "e6", "Nc3", "Nf6", "Bg5"] },
        { name: "English Opening", moves: ["c4", "e5", "Nc3", "Nf6", "g3", "d5"] },
        { name: "Sicilian Defense", moves: ["e4", "c5", "Nf3", "d6", "d4", "cxd4", "Nxd4", "Nf6", "Nc3", "a6"] }
    ];

    // ========================================================================
    // UI HELPERS
    // ========================================================================
    function log(msg) {
        const logEl = document.getElementById('log');
        const entry = document.createElement('div');
        entry.className = 'log-entry';
        entry.innerHTML = `<span>[${new Date().toLocaleTimeString()}]</span> ${msg}`;
        logEl.appendChild(entry);
        logEl.scrollTop = logEl.scrollHeight;
    }

    function updateStatus(msg) {
        document.getElementById('status').innerText = msg;
    }

    function renderMoveHistory() {
        const moves = game.history();
        const container = document.getElementById('move-history');
        container.innerHTML = '';
        if (!moves.length) {
            container.innerHTML = '<div class="muted">No moves yet.</div>';
            return;
        }
        for (let i = 0; i < moves.length; i += 2) {
            const row = document.createElement('div');
            row.className = 'move-row';
            row.innerHTML = `<span>${(i / 2) + 1}.</span><span>${moves[i] || ''}</span><span>${moves[i + 1] || ''}</span>`;
            container.appendChild(row);
        }
        container.scrollTop = container.scrollHeight;
    }

    function renderBoard() {
        boardEl.innerHTML = '';
        for (let i = 0; i < 64; i++) {
            let squareIdx = isFlipped ? 63 - i : i;
            let rank = 7 - Math.floor(squareIdx / 8);
            let file = squareIdx % 8;
            let squareName = String.fromCharCode(97 + file) + (rank + 1);
            let div = document.createElement('div');
            let isLight = (rank + file) % 2 !== 0;
            div.className = `square ${isLight ? 'light' : 'dark'}`;
            div.dataset.square = squareName;
            div.onclick = () => onSquareClick(squareName);
            let piece = game.get(squareName);
            if (piece) {
                let span = document.createElement('span');
                span.className = 'piece';
                span.innerText = piece.color === 'w' ? pieces[piece.type.toUpperCase()] : pieces[piece.type];
                span.style.color = piece.color === 'w' ? '#fff' : '#0f0';
                if (piece.color === 'b') span.style.textShadow = '0 0 5px #0f0';
                div.appendChild(span);
            }
            if (selectedSquare === squareName) div.classList.add('selected');
            const history = game.history({ verbose: true });
            if (history.length) {
                const last = history[history.length - 1];
                if (last.from === squareName || last.to === squareName) div.classList.add('last-move');
            }
            if (hintSquares.includes(squareName)) div.classList.add('hint');
            boardEl.appendChild(div);
        }
        updateEvalBar();
    }

    // ========================================================================
    // TIMERS & SOUND
    // ========================================================================
    function formatTime(seconds) {
        const total = Math.max(0, Math.floor(seconds));
        const m = Math.floor(total / 60).toString().padStart(2, '0');
        const s = (total % 60).toString().padStart(2, '0');
        return `${m}:${s}`;
    }

    function updateClockDisplay() {
        document.getElementById('white-clock').innerText = formatTime(timeRemaining.w);
        document.getElementById('black-clock').innerText = formatTime(timeRemaining.b);
    }

    function startTimer(side) {
        clearInterval(timerInterval);
        if (timeExpired) return;
        tickingSide = side;
        let lastTick = Date.now();
        timerInterval = setInterval(() => {
            const now = Date.now();
            const delta = Math.floor((now - lastTick) / 1000);
            if (delta > 0) {
                lastTick = now;
                timeRemaining[tickingSide] -= delta;
                if (timeRemaining[tickingSide] <= 0) {
                    timeRemaining[tickingSide] = 0;
                    updateClockDisplay();
                    clearInterval(timerInterval);
                    timeExpired = true;
                    updateStatus(`${tickingSide === 'w' ? 'White' : 'Black'} ran out of time.`);
                    log(`Clock Flag: ${tickingSide === 'w' ? 'White' : 'Black'} loses on time.`);
                    return;
                }
                updateClockDisplay();
            }
        }, 500);
    }

    function stopTimer() {
        clearInterval(timerInterval);
    }

    function playSound(type) {
        if (!soundEnabled || typeof AudioContext === 'undefined') return;
        const ctxAudio = new (window.AudioContext || window.webkitAudioContext)();
        const o = ctxAudio.createOscillator();
        const g = ctxAudio.createGain();
        const freq = type === 'capture' ? 440 : type === 'check' ? 520 : 380;
        o.frequency.value = freq;
        o.type = 'sine';
        g.gain.setValueAtTime(0.06, ctxAudio.currentTime);
        g.gain.exponentialRampToValueAtTime(0.0001, ctxAudio.currentTime + 0.25);
        o.connect(g);
        g.connect(ctxAudio.destination);
        o.start();
        o.stop(ctxAudio.currentTime + 0.25);
    }

    // ========================================================================
    // EVALUATION & SEARCH
    // ========================================================================
    function isEndgame(board) {
        let queens = 0;
        let minorMajor = 0;
        board.flat().forEach(p => {
            if (!p) return;
            if (p.type === 'q') queens++;
            if (['r', 'b', 'n'].includes(p.type)) minorMajor++;
        });
        return queens === 0 || (queens === 2 && minorMajor <= 4);
    }

    function evaluateBoardState(chessInstance) {
        const board = chessInstance.board();
        const endgame = isEndgame(board);
        let score = 0;
        for (let r = 0; r < 8; r++) {
            for (let c = 0; c < 8; c++) {
                const piece = board[r][c];
                if (!piece) continue;
                let idx = r * 8 + c;
                let val = pieceValues[piece.type];
                const table = piece.type === 'k' && endgame ? pst.k_end : pst[piece.type];
                const tableIndex = piece.color === 'w' ? idx : 63 - idx;
                val += table ? table[tableIndex] : 0;
                score += piece.color === 'w' ? val : -val;
            }
        }
        return score;
    }

    function minimax(depth, chessInstance, alpha, beta, maximizingPlayer) {
        if (depth === 0 || chessInstance.game_over()) {
            if (chessInstance.in_checkmate()) {
                return chessInstance.turn() === 'w' ? -999999 : 999999;
            }
            if (chessInstance.in_draw()) return 0;
            return evaluateBoardState(chessInstance);
        }
        const moves = chessInstance.moves({ verbose: true });
        if (maximizingPlayer) {
            let maxEval = -Infinity;
            for (const move of moves) {
                chessInstance.move(move);
                const evalScore = minimax(depth - 1, chessInstance, alpha, beta, false);
                chessInstance.undo();
                maxEval = Math.max(maxEval, evalScore);
                alpha = Math.max(alpha, evalScore);
                if (beta <= alpha) break;
            }
            return maxEval;
        } else {
            let minEval = Infinity;
            for (const move of moves) {
                chessInstance.move(move);
                const evalScore = minimax(depth - 1, chessInstance, alpha, beta, true);
                chessInstance.undo();
                minEval = Math.min(minEval, evalScore);
                beta = Math.min(beta, evalScore);
                if (beta <= alpha) break;
            }
            return minEval;
        }
    }

    function shuffleArray(arr) {
        for (let i = arr.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [arr[i], arr[j]] = [arr[j], arr[i]];
        }
    }

    function searchBestMove() {
        const clone = new Chess(game.fen());
        const { depth, randomness } = difficultySettings[difficulty];
        const candidates = [];
        const maximizing = clone.turn() === 'w';
        const moves = clone.moves({ verbose: true });
        shuffleArray(moves);
        let target = maximizing ? -Infinity : Infinity;
        for (const move of moves) {
            clone.move(move);
            const value = minimax(depth - 1, clone, -Infinity, Infinity, !maximizing);
            clone.undo();
            if (maximizing) {
                if (value > target) {
                    target = value;
                    candidates.length = 0;
                    candidates.push({ move, value });
                } else if (Math.abs(value - target) < 10) {
                    candidates.push({ move, value });
                }
            } else {
                if (value < target) {
                    target = value;
                    candidates.length = 0;
                    candidates.push({ move, value });
                } else if (Math.abs(value - target) < 10) {
                    candidates.push({ move, value });
                }
            }
        }
        if (!candidates.length) return null;
        if (Math.random() < randomness && candidates.length > 1) {
            return candidates[Math.floor(Math.random() * candidates.length)].move;
        }
        return candidates[0].move;
    }

    function getOpeningBookMove() {
        const history = game.history();
        for (const line of openingBook) {
            if (history.length < line.moves.length) {
                let match = true;
                for (let i = 0; i < history.length; i++) {
                    if (history[i] !== line.moves[i]) { match = false; break; }
                }
                if (match) {
                    const san = line.moves[history.length];
                    const legal = game.moves({ verbose: true }).find(m => m.san === san);
                    if (legal) {
                        log(`Opening Book: ${line.name}`);
                        return legal;
                    }
                }
            }
        }
        return null;
    }

    // ========================================================================
    // GAME INTERACTION
    // ========================================================================
    function onSquareClick(square) {
        if (game.game_over() || timeExpired) return;
        if (selectedSquare === square) {
            selectedSquare = null;
            renderBoard();
            return;
        }
        if (selectedSquare) {
            let move = game.move({ from: selectedSquare, to: square, promotion: 'q' });
            if (move) {
                hintSquares = [];
                log(`You played: ${move.san}`);
                playSound(move.captured ? 'capture' : 'move');
                selectedSquare = null;
                renderBoard();
                renderMoveHistory();
                checkGameState();
                if (!game.game_over() && !timeExpired) {
                    startTimer(game.turn());
                    if (!twoPlayerMode) setTimeout(aiMove, 250);
                }
            } else {
                let piece = game.get(square);
                if (piece && piece.color === game.turn()) {
                    selectedSquare = square;
                } else {
                    selectedSquare = null;
                }
                renderBoard();
            }
        } else {
            let piece = game.get(square);
            if (piece && piece.color === game.turn()) {
                selectedSquare = square;
                renderBoard();
            }
        }
    }

    function checkGameState() {
        if (game.in_checkmate()) {
            stopTimer();
            timeExpired = true;
            updateStatus("CHECKMATE. Game Over.");
            log("Result: " + (game.turn() === 'w' ? "0-1" : "1-0"));
            playSound('check');
        } else if (game.in_draw()) {
            stopTimer();
            timeExpired = true;
            updateStatus("DRAW DETECTED.");
            log("Result: 1/2-1/2");
        } else if (game.in_check()) {
            updateStatus("WARNING: King in Check");
            playSound('check');
        } else {
            updateStatus(game.turn() === 'w' ? "White's Turn" : "Black's Turn");
        }
    }

    function aiMove() {
        if (twoPlayerMode || timeExpired || game.game_over()) return;
        startTimer('b');
        setTimeout(() => {
            let move = getOpeningBookMove();
            if (!move) move = searchBestMove();
            if (!move) return;
            game.move(move);
            hintSquares = [];
            playSound(move.captured ? 'capture' : 'move');
            renderBoard();
            renderMoveHistory();
            checkGameState();
            log(`GM 3000 plays: ${move.san}`);
            if (game.in_check()) log("GM 3000: You are exposed.");
            if (!game.game_over() && !timeExpired) startTimer('w');
        }, 150);
    }

    function updateEvalBar() {
        const EVAL_BAR_CENTER = 50;
        const EVAL_BAR_MIN = 5;
        const EVAL_BAR_MAX = 95;
        let score = evaluateBoardState(game);
        let percent = EVAL_BAR_CENTER + score / 50;
        if (percent < EVAL_BAR_MIN) percent = EVAL_BAR_MIN;
        if (percent > EVAL_BAR_MAX) percent = EVAL_BAR_MAX;
        document.getElementById('eval-fill').style.width = percent + "%";
    }

    function resetGame() {
        game.reset();
        selectedSquare = null;
        hintSquares = [];
        timeExpired = false;
        timeRemaining = { w: INITIAL_TIME, b: INITIAL_TIME };
        updateClockDisplay();
        renderBoard();
        renderMoveHistory();
        log("System Reset. New Game initialized.");
        updateStatus("Ready.");
        startTimer('w');
    }

    function flipBoard() {
        isFlipped = !isFlipped;
        renderBoard();
    }

    function undoMove() {
        if (!game.history().length || timeExpired) return;
        let undoCount = twoPlayerMode ? 1 : Math.min(2, game.history().length);
        for (let i = 0; i < undoCount; i++) game.undo();
        selectedSquare = null;
        hintSquares = [];
        renderBoard();
        renderMoveHistory();
        updateStatus(game.turn() === 'w' ? "White's Turn" : "Black's Turn");
        if (!timeExpired) startTimer(game.turn());
    }

    function exportPGN() {
        const pgn = game.pgn();
        if (navigator.clipboard) navigator.clipboard.writeText(pgn).then(() => log("PGN copied to clipboard."));
        const blob = new Blob([pgn], { type: 'text/plain' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'the-terminal-game.pgn';
        a.click();
        URL.revokeObjectURL(url);
        log("PGN export ready.");
    }

    function toggleMode() {
        twoPlayerMode = !twoPlayerMode;
        document.getElementById('mode-btn').innerText = twoPlayerMode ? "Mode: 2 PLAYERS" : "Mode: VS AI";
        log(twoPlayerMode ? "Two-player mode engaged." : "AI mode engaged.");
        if (!twoPlayerMode && game.turn() === 'b' && !game.game_over()) aiMove();
    }

    function toggleSound() {
        soundEnabled = !soundEnabled;
        document.getElementById('sound-btn').innerText = soundEnabled ? "Sound: ON" : "Sound: OFF";
    }

    function suggestMove() {
        if (timeExpired || game.game_over()) return;
        let move = getOpeningBookMove();
        if (!move) move = searchBestMove();
        if (!move) return;
        hintSquares = [move.from, move.to];
        renderBoard();
        log(`Hint: ${move.san}`);
    }

    function setDifficulty(value) {
        difficulty = value;
        log(`Difficulty set to ${value.toUpperCase()}`);
    }

    // ========================================================================
    // INITIALIZATION
    // ========================================================================
    renderBoard();
    renderMoveHistory();
    log("GM 3000 Neural Net Loaded.");
    log("Target: Human User");
    updateClockDisplay();
    startTimer('w');
</script>
</body>
</html>
